% bash, loop

# Loop numerical
for i in {<start>..<end>..<step>}; do
  echo $i
done

# Loop from array
inputs=('foo' 'bar')
for i in ${inputs[@]}; do
  echo $i
done

# Change file extensions
for i in *.<source_extension>; do
  mv $i ${i//<source_extension>/<target_extension>}
done

% bash, map

# Declare map
declare -A map=([john]=75 [doe]=82 [ann]=83 [ava]=72)

# Loop from map
declare -A map=([john]=75 [doe]=82 [ann]=83 [ava]=72)
for key in "${!map[@]}"; do
    echo "${key}: ${map[${key}]}"
done

% bash, sd

# Replace all occurrences
sd <before> <after>

# Replace newlines
sd '\n' '<target_character>'

# Search and replace with regex and indexed capture groups
sd '<regex>' '$1'

# Preview change
sd -p '<before>' '<after>' <input_file>

$ input_file: ls -p | grep -v /

% bash, awk

# Print Nth element
awk '{ print $<index> }'

# Print Nth element with custom field separator
awk -F'<field_separator>' '{ print $<index> }'

# Print elements and concat with spaces
awk '{ print $<index_1>,$<index_2> }'

# Print elements and concat with commas
awk '{ print $<index_1> "," $<index_2> }'

# Print number of row
awk '{ print NR " " $<index> }'

# AWK with regex
awk '/<regex>/ { print $<index> }'

# AWK with match field
awk '$<index_1> == "<match_field>" { print $<index_2> }'

# Matches within specific field
awk '$<index_1>~/<regex>/ { print $<index_2> }'

# Printf with substr (index starts from 1)
awk '{ printf "%s\n", substr($<index>, <from>, <to>) }'

# Set the desired column width
awk '{ printf "%-<column_width>s \t %s \n", NR, $<index> }'

# print the total number of input lines
awk 'END { print NR }'

# print the tenth input line
awk 'NR == 10'

# print the last field of every input line
awk '{ print $NF }'

# print the last field of the last input line
awk '
    { field = $NF }
END { print field }'

# print every input line with  more than n fields
awk 'NF > <nb_fields>'

# print every input line in which the last field is more than n
awk '$NF > <number>'

# print the total number of fields in all input lines
awk '
    { nf = nf + NF}
END { print nf }'

# print the total number of lines that contains a string
awk '
/<search>/ { nlines = nlines + 1 }
END    { print nlines }'

# print the largest first field and the line that contains it
awk '
$1 > max { max = $1; maxline = $0 }
END      { print max, maxline }'

# print every line longer than 80 characters
awk 'length($0) > <nb_characters>'

# print the number of fields in every line followed by the field itself
awk '{ print NF, $0 }'

# exchange the first two fields of every line
awk '{ temp = $1; $1 = $2; $2 = temp; print }'

# print every line after erasing the second field
awk '{ $2 = ""; print }'

# print every line with line number
awk '{ print NR, $0 }'

# print the sums of the fields of every line
awk '
{
  sum = 0
  for (i = 1; i <= NF; i = i + 1)
    sum = sum + $i
  print sum
}'

% bash, tail

# Tail logs from remote container
ssh <host> 'docker logs --tail <nb_last_logs> -f <service_name>' | jq --unbuffered -jr '."@timestamp", " [", .level, "] ", .message, "\n", .stack_trace | select(.!=null)' | sed --unbuffered -e 's~\(.*ERROR.*\)~\o033[0;41m\1\o033[0m~' -e 's~\(.*WARN.*\)~\o033[1;43;1;30m\1\o033[0m~' -e 's~\(.*DEBUG.*\)~\o033[1;30m\1\o033[0m~'

# Tail logs from remote container of all servers
env=<env> && app=<app> && tailr --lines 10 --env ${env} --app ${app}

# Get env variables from remote container
ssh <host> 'docker exec <service_name> env' | sort

$ host: cat /etc/hosts | awk '{ print $2 }' | sort | uniq
$ service_name: ssh <host> 'docker ps -a --format "{{.Names}}"' | grep -v cadvisor | grep -v liquibase
$ env: find ~/work/big-cloud/config/ -maxdepth 1 -type d | awk -F'/' '{ print $7 }' | sort | uniq
$ app: find ~/work/big-cloud/ansible/playbooks/files/applications/ -maxdepth 1 -type d | awk -F'/' '{ print $10 }' | sort | uniq

% bash, date

# Convert epoch timestamp to human readable
date -u --date=@$((<timestamp_in_milli>/1000)).$((<timestamp_in_milli>%1000)) "+%Y-%m-%dT%H:%M:%S.%3NZ"

# Convert human readable to epoch timestamp in second
date -d '<timestamp_in_iso_8601>' +%s%3N

% bash, grep

# Extract specific text
grep -o '<prefix>\(.*\)<suffix>' <file> | sed 's/<prefix>\(.*\)<suffix>/\1/'

% bash, sort

# Sort file by nth column
sort -k <n> <input_file>

$ input_file: ls -p | grep -v /

% bash, file

# Get folder Names
for f in */; do echo $f; done

% systemd

# Restart service
systemctl restart <service>

# View service's logs
systemctl -l status <service>

# View all service's logs
journalctl -u <service>

$ service: systemctl list-units | grep '.service' | awk '{ print $1 }'

