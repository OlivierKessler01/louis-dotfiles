% bash, common

$ input_file: ls -p | grep -v /

# -----------------------------------------------------------------

% bash, ls, file

# List files sorted by modification date
ls -lt

# List all files, without current and parent directories
ls -A

# List files sorted by size
ls -l -S

% bash, tree

# List only directory in tree-like format
tree -d

# List files in tree-like format with display depth
tree -L <display_depth>

# Get folder Names
for f in */; do echo $f; done

# -----------------------------------------------------------------

% bash, cat
@ bash, common

# Write multilines file
cat <<EOF > <file>
<file_content>
EOF

# Display line numbers with output
cat --number <input_file>

# Display line numbers with output and skip empty lines when counting lines
cat --number-nonblank <input_file>

# -----------------------------------------------------------------

% bash, sd
@ bash, common

# Replace all occurrences
sd <before> <after>

# Replace newlines
sd '\n' '<target_character>'

# Search and replace with regex and indexed capture groups
sd '<regex>' '$1'

# Preview change
sd -p '<before>' '<after>' <input_file>

# -----------------------------------------------------------------

% bash, tar

# Extract archive.tar.xz file
tar -xf <input_file>

# Extract archive.tar.xz file in a directory
tar -xf <input_file> -C <output_directory>

# Extract specific file from archive.tar.xz
tar -xf <input_file> <file1>

# List archive.tar.xz content
tar -tvf <input_file>

$ input_file: ls -p *.tar.xz
$ output_directory: echo */ | tr ' ' '\n'

# -----------------------------------------------------------------

% bash, awk

# Print Nth element
awk '{ print $<index> }'

# Print Nth element with custom field separator
awk -F'<field_separator>' '{ print $<index> }'

# Print elements and concat with spaces
awk '{ print $<index_1>,$<index_2> }'

# Print elements and concat with commas
awk '{ print $<index_1> "," $<index_2> }'

# Print number of row
awk '{ print NR " " $<index> }'

# AWK with regex
awk '/<regex>/ { print $<index> }'

# AWK with match field
awk '$<index_1> == "<match_field>" { print $<index_2> }'

# Matches within specific field
awk '$<index_1>~/<regex>/ { print $<index_2> }'

# Printf with substr (index starts from 1)
awk '{ printf "%s\n", substr($<index>, <from>, <to>) }'

# Set the desired column width
awk '{ printf "%-<column_width>s \t %s \n", NR, $<index> }'

# Print the total number of input lines
awk 'END { print NR }'

# Print the tenth input line
awk 'NR == 10'

# Print the last field of every input line
awk '{ print $NF }'

# Print the last field of the last input line
awk '
    { field = $NF }
END { print field }'

# Print every input line with  more than n fields
awk 'NF > <nb_fields>'

# Print every input line in which the last field is more than n
awk '$NF > <number>'

# Print the total number of fields in all input lines
awk '
    { nf = nf + NF}
END { print nf }'

# Print the total number of lines that contains a string
awk '
/<search>/ { nlines = nlines + 1 }
END    { print nlines }'

# Print the largest first field and the line that contains it
awk '
$1 > max { max = $1; maxline = $0 }
END      { print max, maxline }'

# Print every line longer than 80 characters
awk 'length($0) > <nb_characters>'

# Print the number of fields in every line followed by the field itself
awk '{ print NF, $0 }'

# Exchange the first two fields of every line
awk '{ temp = $1; $1 = $2; $2 = temp; print }'

# Print every line after erasing the second field
awk '{ $2 = ""; print }'

# Print every line with line number
awk '{ print NR, $0 }'

# Print the sums of the fields of every line
awk '
{
  sum = 0
  for (i = 1; i <= NF; i = i + 1)
    sum = sum + $i
  print sum
}'

# -----------------------------------------------------------------

% bash, tail

# Tail logs from remote container
ssh <host> 'docker logs --tail <nb_last_logs> -f <service_name>' \
  | jq --unbuffered \
    -jr '."@timestamp", " [", .level, "] ", .message, "\n", .stack_trace | select(.!=null)' \
  | sed --unbuffered \
    -e 's~\(.*ERROR.*\)~\o033[0;41m\1\o033[0m~' \
    -e 's~\(.*WARN.*\)~\o033[1;43;1;30m\1\o033[0m~' \
    -e 's~\(.*DEBUG.*\)~\o033[1;30m\1\o033[0m~'

# Tail logs from remote container of all servers
env=<env> && app=<app> && tailr --lines 10 --env ${env} --app ${app}

# Get env variables from remote container
ssh <host> 'docker exec <service_name> env' | sort

$ host: cat /etc/hosts | awk '{ print $2 }' | sort | uniq
$ service_name: ssh <host> 'docker ps -a --format "{{.Names}}"' | grep -v cadvisor | grep -v liquibase
$ env: find ~/work/big-cloud/config/ -maxdepth 1 -type d | awk -F'/' '{ print $7 }' | sort | uniq
$ app: find ~/work/big-cloud/ansible/playbooks/files/applications/ -maxdepth 1 -type d | awk -F'/' '{ print $10 }' | sort | uniq

# -----------------------------------------------------------------

% bash, date

# Convert epoch timestamp to human readable
date -u --date=@$((<timestamp_in_milli>/1000)).$((<timestamp_in_milli>%1000)) "+%Y-%m-%dT%H:%M:%S.%3NZ"

# Convert human readable to epoch timestamp in second
date -d '<timestamp_in_iso_8601>' +%s%3N

# -----------------------------------------------------------------

% bash, grep

# Extract specific text
grep -o '<prefix>\(.*\)<suffix>' <file> | sed 's/<prefix>\(.*\)<suffix>/\1/'

# Find all lines that do not contain filter
grep -v <filter> <input_file>

# -----------------------------------------------------------------

% bash, sort
@ bash, common

# Sort file by nth column
sort -k <n> <input_file>

# Find duplicate lines
sort <input_file> | uniq -c | awk '$1 > 1 { print $2 }'

# -----------------------------------------------------------------

% systemd

# Restart service
systemctl restart <service>

# View service's logs
systemctl -l status <service>

# View all service's logs
journalctl -u <service>

$ service: systemctl list-units | grep '.service' | awk '{ print $1 }'

# -----------------------------------------------------------------

% job

# List current jobs
jobs

# Create a job in the background
<cmd> &

# Bring the last job to the foreground
fg %1

# Bring a job back to the background
bg %1

# Disowning background job (allow process to continue once the shell session is closed)
disown %1

# -----------------------------------------------------------------

% bash, script

# Print error messages to stderr
<cmd> || echo 'cmd failed' >/dev/stderr

# Print error messages to stderr in a function
err() {
  echo "\033[0;41m[ERR] $*\033[0m" >>/dev/stderr
}

# Generate random number
echo $((1 + RANDOM % 10))

# -----------------------------------------------------------------

% bash, script, string manipulation

# Replace first match pattern in String
echo "${<variable>/<pattern>/<replacement>}"

# Replace all match in String
echo "${<variable>//<pattern>/<replacement>}"

# Replace match at the beginning in String
echo "${<variable}/#<pattern>/<replacement}"

# Replace match at the end in String
echo "${<variable>/%<pattern>/<replacement}"

# Add prefix to array items
echo "${<variable>[@]/#/<prefix>}"

# Substring from beginning (zero-based offset): var='0123456789abcdef' && echo "${var:3}" => 3456789abcdef
echo "${<variable>:<end_index>}"

# Substring from offset with length: var='0123456789abcdef' && echo "${var:3:4}" => 3456
echo "${<variable>:<start_index>:<length>}"

# Substring from the end (negative offset, use a space or parenthese): var='0123456789abcdef' && echo "${var:(-6)}" => abcdef
echo "${<variable>:(-<end_index>)}"

# Substring from offset with negative length to count from the end: var='0123456789abcdef' && echo "${var:3:-5}" => 3456789a
echo "${<variable>:<start_index>:-<length>}"

# Delete a pattern from the beginning of a String with the shortest match: a='I am a string' && echo "${a#*a}" => m a string
echo "${<variable>#*<pattern>}"

# Delete a pattern from the beginning of a String with the longest match: a='I am a string' && echo "${a##*a}" => string
echo "${<variable>##*<pattern>}"

# -----------------------------------------------------------------

% bash, array

# Create an array
array=('first element' 'second element')

# Assign script's input arguments in array
array=("$@")

# Print array element at index 0 of an array
echo "${array[0]}"

# Print last array element of an array
echo "${array[-1]}"

# Print all elements of an array
echo "${array[@]}"

# Print all elements from index 1 of an array
echo "${array[@]:1}"

# Print 3 elements from index 1 of an array
echo "${array[@]:1:3}"

# Print first 3 characters of first element of an array
echo "${array[0]:0:3}"

# Append array
array+=('fourth element' 'fifth element')

# Prepend array
array=('new element' "${array[@]}")

# Print array indexes
echo "{${!array[@]}}"

# Merge arrays
array3=("${array1[@]} ${array2[@]}")

# Print the array length
echo "${#array[@]}"}

# Delete array indexes
unset -v 'array[1]'

# Delete an array
unset array

# -----------------------------------------------------------------

% bash, map

# Declare map
declare -A map=([john]=75 [doe]=82 [ann]=83 [ava]=72)

# Loop from map
declare -A map=([john]=75 [doe]=82 [ann]=83 [ava]=72)
for key in "${!map[@]}"; do
    echo "${key}: ${map[${key}]}"
done

# Append elements to map
declare -a map
map+=(1 2 3)
map+=(4 5 6)

# Remove element from map
unset "map[${i}]"

# -----------------------------------------------------------------

% bash, script, loop

# Loop numerical
for i in {<start>..<end>..<step>}; do
  echo $i
done

# Loop from array using for loop
inputs=('foo' 'bar')
for i in ${inputs[@]}; do
  echo $i
done

# Loop from array using for loop
for (( i=0; i<${#arr[@]}; i++ )); do
  echo "${arr[$i]}"
done

# Loop from array using for while loop
i=0
while [ $i -lt ${#arr[@]} ]; do
  echo "${arr[$i]}"
  i="$((i + 1)"
done

# Loop from array using for while loop
i=0
while (( $i < ${#arr[@]} )); do
  echo "${arr[$i]}"
  i="$((i + 1)"
done

# Change file extensions
for i in *.<source_extension>; do
  mv $i ${i//<source_extension>/<target_extension>}
done

# For loop continue
for i in [series]; do
  command 1
  command 2
  if [ condition ]; then
    continue # skip to the next value in "series"
  fi
  command 3
done

# For loop break
for i in [series]; do
  command 4
  if [ condition ]; then
    command 5 # Command if the loop needs to be broken
    break
  fi
  command 6 # Command to run if the "condition" is never true
done

# Execute command until condition is true
i=5
until [[ i -eq 10 ]]; do
  echo "i=$i"
  i="$((i+1))"
done

